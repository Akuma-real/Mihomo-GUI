#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import pwd
import shutil
import subprocess
import sys
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter import scrolledtext
import re

SERVICE = "mihomo"
# GUI 环境变量仍可覆盖，但按钮可用性取决于是否配置了 external-controller
DASHBOARD_URL = os.environ.get("MIHOMO_DASHBOARD_URL", "http://127.0.0.1:9090/ui")

try:
    import yaml  # type: ignore
    _HAVE_YAML = True
except Exception:
    _HAVE_YAML = False


def have(cmd: str) -> bool:
    return shutil.which(cmd) is not None


def run(cmd, check=True, capture_output=True, text=True):
    return subprocess.run(cmd, check=check, capture_output=capture_output, text=text)


def run_root(cmd):
    # 在 GUI 场景下优先使用 pkexec 弹出认证框
    if os.geteuid() == 0:
        return run(cmd)
    if have("pkexec"):
        return run(["pkexec", *cmd])
    # 无 polkit 时给出友好提示
    raise RuntimeError("未找到 pkexec。请安装 polkit 或以 root 运行本程序。")


def run_systemctl(cmd_args):
    """优先直接调用 systemctl，让 polkit 代理弹窗并复用认证；
    无代理或被拒时再回退到 pkexec。"""
    try:
        return run(["systemctl", *cmd_args])
    except subprocess.CalledProcessError as e:
        msg = (e.stderr or "") + (e.stdout or "")
        # 常见提示：Interactive authentication required.
        # 或权限不足等情况，尝试 pkexec 回退一次
        if "Interactive authentication required" in msg or "permission denied" in msg.lower() or "access denied" in msg.lower():
            return run_root(["systemctl", *cmd_args])
        raise


def is_active() -> bool:
    r = subprocess.run(["systemctl", "is-active", "--quiet", SERVICE])
    return r.returncode == 0


def is_enabled() -> bool:
    r = subprocess.run(["systemctl", "is-enabled", "--quiet", SERVICE])
    return r.returncode == 0


class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Mihomo 控制面板")
        self.geometry("560x340")
        self.resizable(False, False)
        self._build()
        self.refresh_status()

    def _build(self):
        pad = {"padx": 8, "pady": 8}

        frm_top = ttk.Frame(self)
        frm_top.pack(fill=tk.X, **pad)

        self.lbl_status = ttk.Label(frm_top, text="服务状态：未知", font=(None, 11, "bold"))
        self.lbl_status.pack(side=tk.LEFT)

        self.lbl_enabled = ttk.Label(frm_top, text=" | 开机自启：未知", font=(None, 10))
        self.lbl_enabled.pack(side=tk.LEFT)

        # 配置文件显示与选择
        frm_cfg = ttk.Frame(self)
        frm_cfg.pack(fill=tk.X, **pad)
        ttk.Label(frm_cfg, text="当前配置：").pack(side=tk.LEFT)
        self.var_cfg = tk.StringVar(value=self._get_current_config())
        self.ent_cfg = ttk.Entry(frm_cfg, textvariable=self.var_cfg, width=56)
        self.ent_cfg.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0,8))
        ttk.Button(frm_cfg, text="选择...", command=self.choose_config).pack(side=tk.LEFT)
        ttk.Button(frm_cfg, text="打开 sysconfig", command=self.open_sysconfig_editor).pack(side=tk.LEFT, padx=(8,0))

        frm_btn = ttk.Frame(self)
        frm_btn.pack(fill=tk.BOTH, expand=True, **pad)

        # 第一行：启动/停止/重启
        ttk.Button(frm_btn, text="启动", command=self.start).grid(row=0, column=0, sticky="nsew", **pad)
        ttk.Button(frm_btn, text="停止", command=self.stop).grid(row=0, column=1, sticky="nsew", **pad)
        ttk.Button(frm_btn, text="重启", command=self.restart).grid(row=0, column=2, sticky="nsew", **pad)

        # 第二行：启用/禁用 开机自启
        ttk.Button(frm_btn, text="启用自启", command=self.enable).grid(row=1, column=0, sticky="nsew", **pad)
        ttk.Button(frm_btn, text="禁用自启", command=self.disable).grid(row=1, column=1, sticky="nsew", **pad)
        ttk.Button(frm_btn, text="查看状态", command=self.show_status).grid(row=1, column=2, sticky="nsew", **pad)

        # 第三行：打开 Dashboard 与退出
        self.btn_open = ttk.Button(frm_btn, text="打开 Dashboard", command=self.open_dashboard)
        self.btn_open.grid(row=2, column=0, columnspan=2, sticky="nsew", **pad)
        ttk.Button(frm_btn, text="退出", command=self.destroy).grid(row=2, column=2, sticky="nsew", **pad)

        for i in range(3):
            frm_btn.columnconfigure(i, weight=1)
        for i in range(3):
            frm_btn.rowconfigure(i, weight=1)

        frm_hint = ttk.Frame(self)
        frm_hint.pack(fill=tk.X, **pad)
        ttk.Label(frm_hint, text="提示：需要进行启动/停止等操作时会请求提权（pkexec）").pack(side=tk.LEFT)
        # 初始化“打开 Dashboard”按钮状态
        self._update_open_button()

    def _sysconfig_path(self) -> str:
        return "/etc/sysconfig/mihomo"

    def _get_current_config(self) -> str:
        path = self._sysconfig_path()
        try:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    s = line.strip()
                    if not s or s.startswith('#'):
                        continue
                    if s.startswith('MIHOMO_CONFIG='):
                        val = s.split('=',1)[1].strip()
                        if (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
                            val = val[1:-1]
                        return val
        except Exception:
            pass
        return ""

    def _effective_home(self) -> str:
        # 在 pkexec 下优先使用原始用户的 HOME
        pk_uid = os.environ.get("PKEXEC_UID")
        if pk_uid is not None:
            try:
                uid = int(pk_uid)
                return pwd.getpwuid(uid).pw_dir
            except Exception:
                pass
        return os.path.expanduser("~")

    def _is_within(self, base: str, path: str) -> bool:
        try:
            base_real = os.path.realpath(base)
            path_real = os.path.realpath(path)
            return os.path.commonpath([base_real, path_real]) == base_real
        except Exception:
            return False

    def choose_config(self):
        home = self._effective_home()
        filename = filedialog.askopenfilename(
            title="选择 mihomo 配置文件（仅限当前用户目录）",
            initialdir=home,
            filetypes=[("YAML 文件", "*.yaml *.yml"), ("所有文件", "*.*")]
        )
        if not filename:
            return
        if not self._is_within(home, filename):
            messagebox.showwarning("不被允许", "仅允许选择当前用户主目录下的配置文件。\n如需使用系统路径，请手动编辑 /etc/sysconfig/mihomo。")
            return
        self.var_cfg.set(filename)
        # 写入 /etc/sysconfig/mihomo 并重启服务
        self.apply_config(filename)
        # 更新按钮状态
        self._update_open_button()

    def open_sysconfig_editor(self):
        path = self._sysconfig_path()
        try:
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception:
            content = (
                "# /etc/sysconfig/mihomo\n"
                "# 设置示例：\n"
                "# MIHOMO_DIR=\"/etc/mihomo\"\n"
                "# MIHOMO_CONFIG=\"/home/yourname/.config/mihomo/config.yaml\"\n"
                "# MIHOMO_EXTRA_ARGS=\"\"\n"
            )

        win = tk.Toplevel(self)
        win.title("编辑 /etc/sysconfig/mihomo")
        win.geometry("760x520")
        win.transient(self)
        win.grab_set()

        txt = scrolledtext.ScrolledText(win, wrap="none", font=("Courier New", 10))
        txt.pack(fill=tk.BOTH, expand=True)
        txt.insert("1.0", content)

        def do_save(restart: bool):
            new_content = txt.get("1.0", tk.END)
            try:
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                run_systemctl(["daemon-reload"])  # 普通模式尽量先尝试
                if restart:
                    self._run_op("重启", ["systemctl", "restart", SERVICE])
                self.var_cfg.set(self._get_current_config())
                messagebox.showinfo("已保存", "sysconfig 已保存" + ("并已重启服务" if restart else ""))
                self._update_open_button()
            except Exception:
                script = (
                    "cat >/etc/sysconfig/mihomo <<'EOF'\n" + new_content + "EOF\n"
                    "systemctl daemon-reload\n" + ("systemctl restart mihomo\n" if restart else "")
                )
                try:
                    run_root(["bash", "-lc", script])
                    self.var_cfg.set(self._get_current_config())
                    messagebox.showinfo("已保存", "sysconfig 已保存" + ("并已重启服务" if restart else ""))
                    self._update_open_button()
                except Exception as e:
                    messagebox.showerror("保存失败", f"无法保存到 {path}:\n{e}")

        frm_btn = ttk.Frame(win)
        frm_btn.pack(fill=tk.X)
        ttk.Button(frm_btn, text="保存", command=lambda: do_save(False)).pack(side=tk.RIGHT, padx=8, pady=8)
        ttk.Button(frm_btn, text="保存并重启服务", command=lambda: do_save(True)).pack(side=tk.RIGHT, padx=0, pady=8)
        ttk.Button(frm_btn, text="关闭", command=win.destroy).pack(side=tk.LEFT, padx=8, pady=8)

    def apply_config(self, config_path: str):
        # 固定系统级工作目录，避免在用户配置目录生成运行文件
        cfg_dir = "/var/lib/mihomo"
        content = (
            f"MIHOMO_DIR=\"{cfg_dir}\"\n"
            f"MIHOMO_CONFIG=\"{config_path}\"\n"
            f"MIHOMO_EXTRA_ARGS=\"\"\n"
        )
        try:
            # 尝试直接写（root 模式）
            with open(self._sysconfig_path(), 'w', encoding='utf-8') as f:
                f.write("# Generated by mihomo-control\n" + content)
            # 重新加载并重启
            run_systemctl(["daemon-reload"])  # 可能不需提权
            self._run_op("重启", ["systemctl", "restart", SERVICE])
            messagebox.showinfo("已应用", f"已切换配置：\n{config_path}")
        except Exception:
            # 回退到提权写入（通过 heredoc 一次性写入）
            cmd_script = (
                "cat >/etc/sysconfig/mihomo <<'EOF'\n"
                "# Generated by mihomo-control\n" + content + "EOF\n"
                "systemctl daemon-reload && systemctl restart mihomo\n"
            )
            try:
                run_root(["bash", "-lc", cmd_script])
                messagebox.showinfo("已应用", f"已切换配置：\n{config_path}")
            except Exception as e:
                messagebox.showerror("写入失败", f"无法写入 /etc/sysconfig/mihomo：\n{e}")
        # 应用后刷新按钮状态
        self._update_open_button()

    def refresh_status(self):
        active = is_active()
        enabled = is_enabled()
        self.lbl_status.configure(text=f"服务状态：{'active' if active else 'inactive'}",
                                  foreground=("#2e7d32" if active else "#c62828"))
        self.lbl_enabled.configure(text=f" | 开机自启：{'enabled' if enabled else 'disabled'}")

    def _run_op(self, op_name: str, cmd):
        try:
            # 优先用普通 systemctl（有 polkit 代理会缓存认证）
            if cmd and cmd[0] == "systemctl":
                run_systemctl(cmd[1:])
            else:
                run_root(cmd)
            self.refresh_status()
        except Exception as e:
            messagebox.showerror("操作失败", f"{op_name} 失败：\n{e}")

    def start(self):
        self._run_op("启动", ["systemctl", "start", SERVICE])

    def stop(self):
        self._run_op("停止", ["systemctl", "stop", SERVICE])

    def restart(self):
        self._run_op("重启", ["systemctl", "restart", SERVICE])

    def enable(self):
        self._run_op("启用自启", ["systemctl", "enable", SERVICE])

    def disable(self):
        self._run_op("禁用自启", ["systemctl", "disable", SERVICE])

    def show_status(self):
        try:
            cp = run(["systemctl", "status", SERVICE, "--no-pager"])  # 非 root 也可读
            StatusDialog(self, cp.stdout)
        except subprocess.CalledProcessError as e:
            out = (e.stdout or "") + "\n" + (e.stderr or "")
            StatusDialog(self, out)

    def open_dashboard(self):
        if not have("xdg-open"):
            messagebox.showinfo("打开失败", f"未找到 xdg-open，请手动打开：\n{DASHBOARD_URL}")
            return
        try:
            # 动态推断 URL：优先根据 YAML external-controller(-tls)
            url = self._infer_dashboard_url()
            if not url:
                messagebox.showwarning("未配置外部控制器", "未在配置中找到 external-controller / external-controller-tls，无法打开 Dashboard。")
                return
            # 若以 root 运行（pkexec 模式），优先以原用户打开浏览器
            if os.geteuid() == 0:
                pk_uid = os.environ.get("PKEXEC_UID")
                if pk_uid is not None:
                    try:
                        uid = int(pk_uid)
                        user = pwd.getpwuid(uid).pw_name
                        env_vars = {}
                        for k in ("DISPLAY", "WAYLAND_DISPLAY", "XDG_RUNTIME_DIR", "DBUS_SESSION_BUS_ADDRESS", "XAUTHORITY"):
                            v = os.environ.get(k)
                            if v:
                                env_vars[k] = v
                        # 以原用户名而非“#UID”运行，避免 runuser 解析失败
                        cmd = ["runuser", "-u", user, "--", "env"] \
                              + [f"{k}={v}" for k, v in env_vars.items()] \
                              + ["xdg-open", url]
                        subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        return
                    except Exception:
                        pass
            # 普通用户模式或回退路径
            subprocess.Popen(["xdg-open", url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            messagebox.showerror("打开失败", f"无法打开浏览器：\n{e}")

    # 推断 Dashboard URL：
    # 1) external-controller-tls -> https://<addr>/ui
    # 2) external-controller     -> http://<addr>/ui
    # 3) 以上均无 -> None（按钮将禁用）
    def _infer_dashboard_url(self):
        path = self.var_cfg.get().strip()
        if not path or not os.path.isfile(path):
            return None
        ctrl_tls = None
        ctrl = None
        # 首选使用 PyYAML
        if _HAVE_YAML:
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    data = yaml.safe_load(f)
                if isinstance(data, dict):
                    ctrl_tls = data.get('external-controller-tls')
                    ctrl = data.get('external-controller')
            except Exception:
                ctrl_tls = None
                ctrl = None
        # 退化：用正则扫描一遍文本（对简单键值足够稳健）
        if ctrl_tls is None and ctrl is None:
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    text = f.read()
                m_tls = re.search(r"^\s*external-controller-tls\s*:\s*([^#\n]+)", text, re.M)
                m = re.search(r"^\s*external-controller\s*:\s*([^#\n]+)", text, re.M)
                if m_tls:
                    ctrl_tls = m_tls.group(1).strip().strip('"\'')
                if m:
                    ctrl = m.group(1).strip().strip('"\'')
            except Exception:
                pass
        # 归一化 0.0.0.0 / ::
        def _normalize_hostport(val):
            if not isinstance(val, str):
                return None
            v = val.strip()
            v = v.strip('"\'')
            # 如果是 0.0.0.0 或 ::，替换为回环地址以便浏览器访问
            if v.startswith('0.0.0.0:'):
                v = '127.0.0.1:' + v.split(':', 1)[1]
            elif v.startswith('::') or v.startswith('[::]'):
                # 尽力匹配端口
                if v.startswith('[::]') and ':' in v[4:]:
                    port = v.split(']:', 1)[1]
                    v = '[::1]:' + port
                else:
                    # 粗略：无方括号时，保留原串
                    v = v.replace('::', '::1')
            return v
        if ctrl_tls:
            vp = _normalize_hostport(ctrl_tls)
            if vp:
                return f"https://{vp}/ui"
        if ctrl:
            vp = _normalize_hostport(ctrl)
            if vp:
                return f"http://{vp}/ui"
        return None

    def _update_open_button(self):
        url = self._infer_dashboard_url()
        if url:
            try:
                self.btn_open.configure(state=tk.NORMAL)
            except Exception:
                pass
        else:
            try:
                self.btn_open.configure(state=tk.DISABLED)
            except Exception:
                pass


class StatusDialog(tk.Toplevel):
    def __init__(self, master, text):
        super().__init__(master)
        self.title("mihomo 状态")
        self.geometry("700x480")
        self.resizable(True, True)
        txt = tk.Text(self, wrap="word", font=("Courier New", 10))
        txt.pack(fill=tk.BOTH, expand=True)
        txt.insert("1.0", text)
        txt.configure(state=tk.DISABLED)


def main():
    # 启动即提权（若不是 root），确保一次认证后整个会话无二次弹窗
    if os.geteuid() != 0 and have("pkexec") and os.environ.get("MIHOMO_SKIP_PKEXEC") != "1":
        # 尝试传递常见图形环境变量，确保 GUI 能在用户会话显示
        env_args = []
        for k in ("DISPLAY", "WAYLAND_DISPLAY", "XDG_RUNTIME_DIR", "DBUS_SESSION_BUS_ADDRESS", "XAUTHORITY"):
            v = os.environ.get(k)
            if v:
                env_args += [f"{k}={v}"]
        exe = shutil.which("mihomo-control") or os.path.realpath(sys.argv[0])
        args = ["pkexec", "env", *env_args, exe]
        os.execvp(args[0], args)

    # 依赖检查：python3-tkinter、polkit（pkexec）
    missing = []
    try:
        import tkinter  # noqa: F401
    except Exception:
        missing.append("python3-tkinter")
    if not have("pkexec") and os.geteuid() != 0:
        missing.append("polkit (pkexec)")
    if missing:
        messagebox.showwarning("依赖缺失", "缺少依赖：\n- " + "\n- ".join(missing) + "\n\n可能无法进行提权操作或显示窗口。")

    app = App()
    app.mainloop()


if __name__ == "__main__":
    main()
